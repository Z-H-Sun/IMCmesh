#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on May 21 2022

Show [uvw] zone axis pattern, i.e. projection of the reciprocal space pattern calculated by 3d fft. Click canvas or press any key to show/hide points/indices.

@author: Z.Sun
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

#==Config==
FILENAME = '44D-A4B7_20.dump.npy' # change filename here, generated by `DUMPvoxelization.py`
MILLER_BRAVAIS = False # For HCP: set this variable to be true in order to use the four-index system instead of three-index
LUMA = (0.02, 0.20) # luma curve minimum and miximum
LIM = 4 # half dimension of the reciprocal box: G^3 \in [-LIM, +LIM]^3
UVW = (1, 1, 1) # which zone axis
COLORMAP = plt.cm.viridis # set to None if grayscale is desired
#==========

UVW /= np.sqrt(np.sum(np.array(UVW)**2))
if COLORMAP is None: COLORMAP = str

d = np.load(FILENAME)
fd= np.fft.fftshift(np.abs(np.fft.fftn(d)))
shape = fd.shape
center= [i//2 for i in shape]

fd2 = (fd-np.min(fd))/(np.max(fd)-np.min(fd)) # normalize


xs=[]; ys=[]; zs=[]; os=[]; ps=[]; ss=[]
rng = range(-LIM, LIM+1)
for x in rng:
    for y in rng:
        for z in rng:
            i = fd2[center[0]+x, center[1]+y, center[2]+z]
            o = (i-LUMA[0])/(LUMA[1]-LUMA[0]) # normalize to [0,1] according to the luma curve
            o = max(0.0, min(1.0, o)) # clip to [0,1]
            if o !=0 and UVW[0]*x + UVW[1]*y + UVW[2]*z == 0:
                xs.append(x); ys.append(y); zs.append(z); os.append(i)
                ps.append(COLORMAP(o))
                ss.append(20+80*o)
fig = plt.figure(figsize=(3, 3))
fig.patch.set_facecolor(COLORMAP(0))
ax = fig.gca(projection='3d', proj_type='ortho')
ax.set_box_aspect([1,1,1]) # this requires matplotlib >= 3.3.0
ax.set_facecolor(COLORMAP(0))
points = ax.scatter(xs, ys, zs, c=ps, s=ss, depthshade=False)
texts = []
print('These indices are shown')
for i,p in enumerate(ps):
    x = xs[i]
    y = ys[i]
    z = zs[i]
    print(x,y,z)
    if MILLER_BRAVAIS:
        if (2*x+y)%4: continue
        a = ' $%s%s%s%s$'%(-y//2,(2*x+y)//4,(y-2*x)//4,z)
    else:
        a = ' $%s%s%s$'%(x,y,z)
    a = a.replace('-','\\bar') # replace negative numbers with \bar number
    t = ax.text(x, y, z, a, size='x-small', zorder=-1, color=p)
    texts.append(t)
ax.set_xlim(-LIM,LIM)
ax.set_ylim(-LIM,LIM)
ax.set_zlim(-LIM,LIM)
ax.elev = np.arcsin(UVW[2])*180/np.pi # w = sin b
if UVW[1] == 0:
    ax.azim = 0
elif UVW[0] == 0:
    ax.azim = 90
else:
    ax.azim = np.arctan(UVW[1]/UVW[0])*180/np.pi # u = cos a cos b, v = sin a sin b
ax._axis3don = False
plt.subplots_adjust(0, 0, 1, 1)
labelsVisibility = -1 # -1: all; 0: indices only; 1: points only
def onclick(event):
    global labelsVisibility
    labelsVisibility %= 3
    labelsVisibility -= 1
    if labelsVisibility > 0:
        print('Now showing points only')
        for i in texts:
            i.set_visible(False)
    elif labelsVisibility < 0:
        print('Now showing points with indices')
        points.set_visible(True)
    else:
        print('Now showing indices only')
        points.set_visible(False)
        for i in texts:
            i.set_visible(True)
    plt.draw()

cid = fig.canvas.mpl_connect('button_press_event', onclick)
cid2 = fig.canvas.mpl_connect('key_press_event', onclick)
print('Click canvas or press any key to show/hide points/indices.')
plt.show()